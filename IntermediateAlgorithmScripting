// 01 - Sum All Numbers In a Range
// We'll pass you an array of two numbers. Return the sum of those two numbers plus the sum of all the numbers between them.
// The lowest number will not always come first.

// firstSolution

function sumAll(arr) {
  var count = 0;
  if (arr[0] < arr[1]) {
      for (var i = arr[0]; i <= arr[1]; i++) {
        count += i;
      }
  } else {
      for (var i = arr[0]; i >= arr[1]; i--) {
        count += i;
      }
    }    
  return count;
}

sumAll([1, 4]);

// secondSolution

function sumAll(arr) {
  let max = Math.max(arr[0], arr[1]);
  let min = Math.min(arr[0], arr[1]);
  return (max * (max + 1) / 2 ) - ( (min - 1) * min / 2);
}



// sumAll([1, 4]) should return a number.
// sumAll([1, 4]) should return 10.
// sumAll([4, 1]) should return 10.
// sumAll([5, 10]) should return 45.
// sumAll([10, 5]) should return 45.



// 02 - Intermediate Algorithm Scripting: Diff Two Arrays
// Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. 
// In other words, return the symmetric difference of the two arrays.

function diffArray(arr1, arr2) {
  //var newArr = [];
  return arr1
    .concat(arr2)
    .filter(item => !arr1.includes(item) || !arr2.includes(item));
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);

// diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]) should return an array.
// ["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return ["pink wool"].
// ["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return an array with one item.
// ["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return ["diorite", "pink wool"].
// ["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return an array with two items.
// ["andesite", "grass", "dirt", "dead shrub"], ["andesite", "grass", "dirt", "dead shrub"] should return [].
// ["andesite", "grass", "dirt", "dead shrub"], ["andesite", "grass", "dirt", "dead shrub"] should return an empty array.
// [1, 2, 3, 5], [1, 2, 3, 4, 5] should return [4].
// [1, 2, 3, 5], [1, 2, 3, 4, 5] should return an array with one item.
// [1, "calf", 3, "piglet"], [1, "calf", 3, 4] should return ["piglet", 4].
// [1, "calf", 3, "piglet"], [1, "calf", 3, 4] should return an array with two items.
// [], ["snuffleupagus", "cookie monster", "elmo"] should return ["snuffleupagus", "cookie monster", "elmo"].
// [], ["snuffleupagus", "cookie monster", "elmo"] should return an array with three items.
// [1, "calf", 3, "piglet"], [7, "filly"] should return [1, "calf", 3, "piglet", 7, "filly"].
// [1, "calf", 3, "piglet"], [7, "filly"] should return an array with six items.



// 03 - Intermediate Algorithm Scripting: Seek and Destroy
// You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments.
// Remove all elements from the initial array that are of the same value as these arguments.
// You have to use the arguments object.

const destroyer = (arr, ...args) => arr.filter(i => !args.includes(i));

// destroyer([1, 2, 3, 1, 2, 3], 2, 3);
// destroyer([1, 2, 3, 1, 2, 3], 2, 3) should return [1, 1].
// destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3) should return [1, 5, 1].
// destroyer([3, 5, 1, 2, 2], 2, 3, 5) should return [1].
// destroyer([2, 3, 2, 3], 2, 3) should return [].
// destroyer(["tree", "hamburger", 53], "tree", 53) should return ["hamburger"].
// destroyer(["possum", "trollo", 12, "safari", "hotdog", 92, 65, "grandma", "bugati", "trojan", "yacht"], "yacht", "possum", "trollo", "safari", "hotdog", "grandma", "bugati", "trojan") should return [12,92,65].


// 04 - Intermediate Algorithm Scripting: Wherefore art thou
// Make a function that looks through an array of objects (first argument) and returns an array of all objects that have 
// matching name and value pairs (second argument). Each name and value pair of the source object has to be present in the 
// object from the collection if it is to be included in the returned array.
// For example, if the first argument is [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, 
// { first: "Tybalt", last: "Capulet" }], and the second argument is { last: "Capulet" }, 
// then you must return the third object from the array (the first argument), because it contains the name and its value, 
// that was passed on as the second argument.


function whatIsInAName(collection, source) {
  // What's in a name?
  var arr = [];
  // Only change code below this line
  
  arr = collection
          .filter(function(item) {
              for (let i in source) {
                if (source[i] != item[i]) {
                  return false;
                } 
              }
           return true;
  });
  

  // Only change code above this line
  return arr;
}


whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" });

// whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" })should return [{ first: "Tybalt", last: "Capulet" }].
// whatIsInAName([{ "apple": 1 }, { "apple": 1 }, { "apple": 1, "bat": 2 }], { "apple": 1 })should return [{ "apple": 1 }, { "apple": 1 }, { "apple": 1, "bat": 2 }].
// whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 })should return [{ "apple": 1, "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }].
// whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "cookie": 2 })should return [{ "apple": 1, "bat": 2, "cookie": 2 }].
// whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }, { "bat":2 }], { "apple": 1, "bat": 2 })should return [{ "apple": 1, "bat": 2 }, { "apple": 1, "bat": 2, "cookie":2 }].
// whatIsInAName([{"a": 1, "b": 2, "c": 3}], {"a": 1, "b": 9999, "c": 3})should return []

// 05 - Intermediate Algorithm Scripting: Spinal Tap Case
// Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.

function spinalCase(str) {
  // "It's such a fine line between stupid, and clever."
  // --David St. Hubbins
  return str
    .split(/\s|_|(?=[A-Z])/)
    .join("-")
    .toLowerCase();
}

// spinalCase("This Is Spinal Tap")should return "this-is-spinal-tap".
// spinalCase("thisIsSpinalTap")should return "this-is-spinal-tap".
// spinalCase("The_Andy_Griffith_Show")should return "the-andy-griffith-show".
// spinalCase("Teletubbies say Eh-oh")should return "teletubbies-say-eh-oh".
// spinalCase("AllThe-small Things")should return "all-the-small-things".



// 06 - Intermediate Algorithm Scripting: Pig Latin
// Translate the provided string to pig latin.
// Pig Latin takes the first consonant (or consonant cluster) of an English word, 
// moves it to the end of the word and suffixes an "ay".
// If a word begins with a vowel you just add "way" to the end.
// Input strings are guaranteed to be English words in all lowercase.


function translatePigLatin(str) {
  let regex = /^[^aeiou]+/;

  if (str.match(regex)) {
    return str.replace(regex, "").concat(str.match(regex) + "ay");
  } else {
    return str.concat("way");
  }
}

// translatePigLatin("consonant");
// translatePigLatin("california")should return "aliforniacay".
// translatePigLatin("paragraphs")should return "aragraphspay".
// translatePigLatin("glove")should return "oveglay".
// translatePigLatin("algorithm")should return "algorithmway".
// translatePigLatin("eight")should return "eightway".
// Should handle words where the first vowel comes in the end of the word.
// Should handle words without vowels.

// 07 - Intermediate Algorithm Scripting: Search and Replace
// Perform a search and replace on the sentence using the arguments provided and return the new sentence.
// First argument is the sentence to perform the search and replace on.
// Second argument is the word that you will be replacing (before).
// Third argument is what you will be replacing the second argument with (after).
// Note
// Preserve the case of the first character in the original word when you are replacing it. 
// For example if you mean to replace the word "Book" with the word "dog", it should be replaced as "Dog"


function myReplace(str, before, after) {
  let i = str.indexOf(before);
  if (str[i] === str[i].toUpperCase()) {
     after = after.charAt(0).toUpperCase() + after.slice(1);
  }
  str = str.replace(before, after);
  return str;
}

myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");


// myReplace("Let us go to the store", "store", "mall")should return "Let us go to the mall".
// myReplace("He is Sleeping on the couch", "Sleeping", "sitting")should return "He is Sitting on the couch".
// myReplace("This has a spellngi error", "spellngi", "spelling")should return "This has a spelling error".
// myReplace("His name is Tom", "Tom", "john")should return "His name is John".
// myReplace("Let us get back to more Coding", "Coding", "algorithms")should return "Let us get back to more Algorithms".


// 08 - Intermediate Algorithm Scripting: DNA Pairing
// The DNA strand is missing the pairing element. Take each character, get its pair, and return the results as a 2d array.
// Base pairs are a pair of AT and CG. Match the missing element to the provided character.
// Return the provided character as the first element in each array.
// For example, for the input GCG, return [["G", "C"], ["C","G"],["G", "C"]]
// The character and its pair are paired up in an array, and all the arrays are grouped into one encapsulating array.


// firstSolution

function pairElement(str) {
  let result = [];
  str.split("");
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "A") {
        result.push(["A","T"]);
    } else if (str[i] === "T") {
        result.push(["T","A"]);
    } else if (str[i] === "C") {
        result.push(["C","G"]);
  } else if (str[i] === "G") {
        result.push(["G","C"]);
    }
  }
  return result;
}

pairElement("GCG")


// secondSolution

function pairElement(str) {
  let result = [];
  str.split("");
  for (let i = 0; i < str.length; i++) {
        str[i] === "A" ? result.push(["A","T"])   
      : str[i] === "T" ? result.push(["T","A"])      
      : str[i] === "C" ? result.push(["C","G"])          
      : result.push(["G","C"]);
  }
  return result;
}

// thirdSolution

function pairElement(str) {
  str = str.split("");
  let matchPair = {
      A: "T",
      T: "A",
      C: "G",
      G: "C"
  }
  return str.map(i => [i, matchPair[i]]);
}


// pairElement("ATCGA")should return [["A","T"],["T","A"],["C","G"],["G","C"],["A","T"]].
// pairElement("TTGAG")should return [["T","A"],["T","A"],["G","C"],["A","T"],["G","C"]].
// pairElement("CTCTA")should return [["C","G"],["T","A"],["C","G"],["T","A"],["A","T"]].


// 09 - Intermediate Algorithm Scripting: Missing letters
// Find the missing letter in the passed letter range and return it.
// If all letters are present in the range, return undefined.

function fearNotLetter(str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== str.charCodeAt(0) + i) {
      return String.fromCharCode(str.charCodeAt(i) - 1);
    }
  }
  return undefined;
}

fearNotLetter("abce");

// fearNotLetter("abce")should return "d".
// fearNotLetter("abcdefghjklmno")should return "i".
// fearNotLetter("stvwx")should return "u".
// fearNotLetter("bcdf")should return "e".
// fearNotLetter("abcdefghijklmnopqrstuvwxyz")should return undefined.



// 10 - Intermediate Algorithm Scripting: Sorted Union
// Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.
// In other words, all values present from all arrays should be included in their original order, but with no duplicates in the final array.
// The unique numbers should be sorted by their original order, but the final array should not be sorted in numerical order.

// firstSolution

function uniteUnique(arr) {
  let result = [];
  for (let x of arguments) {
    for (let y of x) {
      if(result.indexOf(y) === -1) {
        result.push(y);
      }
    }
  }
  return result;
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);


// secondSolution

function uniteUnique(arr) {
  return Array.from(arguments).reduce((x, y) => x.concat(y.filter(z => x.indexOf(z) == -1)), []);
}

// thirdSolution

function uniteUnique(arr) {
  return [...new Set([].concat(...arguments))];
}

// uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1])should return [1, 3, 2, 5, 4].
// uniteUnique([1, 3, 2], [1, [5]], [2, [4]])should return [1, 3, 2, [5], [4]].
// uniteUnique([1, 2, 3], [5, 2, 1])should return [1, 2, 3, 5].
// uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8])should return [1, 2, 3, 5, 4, 6, 7, 8].


